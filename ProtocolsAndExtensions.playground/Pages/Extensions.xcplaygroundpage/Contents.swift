import Foundation

// MARK: - Extensions

/*
 
 Расширения (extension) позволяют добавить новую функциональность к уже существующему объектному типу (классу, структуре, перечислению) или протоколу.
 Таким образом вы можете расширять возможности любых типов, даже тех, что входят в состав Swift, то есть таких типов данных, доступ к исходным кодам которых у вас отсутствует.
 
 С помощью расширений вы можете:
 • добавить вычисляемые свойства экземпляра и вычисляемые свойства типа (static) к объектному типу;
 • добавить методы экземпляра и методы типа к объектному типу;
 • добавить новые инициализаторы, сабскрипты и вложенные типы;
 • подписать тип данных на протокол и обеспечить выполнение его требований.
 Расширения могут добавлять новую функциональность к типу, но не могут изменять существующую. Суть расширения состоит исключительно в наращивании возможностей, но не в их изменении.
 
 СИНТАКСИС
 extension ИмяРасширяемогоТипа {
 // описание новой функциональности для расширяемого типа
 }
 
 Для объявления расширения используется ключевое слово extension, после которого указывается имя расширяемого типа данных. Именно к указанному типу применяются все описанные в теле расширения возможности.
 
 Расширения могут добавлять вычисляемые свойства экземпляра и вычисляемые свойства типа в уже существующий объектный тип.
 
 ПРИМЕЧАНИЕ:
 Расширения могут добавлять только новые вычисляемые свойства. При попытке добавить хранимые свойства или наблюдателей свойств происходит ошибка.
 
 Ваша программа оперирует расстояниями и использует для этого значения типа Double. По умолчанию такое значение определяет расстояние в метрах, но вам требуется организовать оперативный перевод метров в другие единицы измерения расстояний. Для этого расширим тип данных Double и добавим в него несколько специальных вычисляемых свойств.
 
 */

extension Double {
    var asKM: Double { return self / 1000.0 }
    var asM: Double { return self }
    var asCM: Double { return self * 100.0 }
    var asMM: Double { return self * 1000.0 }
}

/*
 
 Теперь при необходимости перевести расстояние из метров в другие единицы мы просто воспользуемся одним из свойств
 
 */

let length: Double = 25 // 25 метров
length.asKM // расстояние 25 метров в километрах - 0.025
length.asMM // расстояние 25 метров в миллиметрах — 25000

//Применение геттеров и сеттеров для вычисляемых свойств позволит использовать их возможности по максимуму

extension Double {
    var asFT: Double {
        get {
            return self / 0.3048
        }
        set(newValue) {
            self = newValue * 0.3048
        }
    } }
var distance: Double = 100 // расстояние 100 метров
distance.asFT // расстояние 100 метров в футах - 328.08 фута
// установим расстояние в футах, но оно будет сохранено в метрах
distance.asFT = 150 // 45.72 метра

/*
 
 Расширения могут добавлять в объектные типы не только свойства, но и методы.
 Рассмотрим пример, в нем появился новый метод repetitions, принимающий на входе замыкание типа () -> (). Данный метод предназначен для того, чтобы выполнять переданное замыкание столько раз, сколько указывает собственное значение целого числа.
 
 */

extension Int {
    func repetitions(task: () -> ()) {
        for _ in 0..<self {
            task() }
    } }
3.repetitions {
    print("Swift")
}

//Консоль

//Swift
//Swift
//Swift

//Так как тип Int является структурой, то для изменения собственного значения экземпляра необходимо использовать ключевое слово mutating.

extension Int {
    mutating func squared() {
        self = self * self
    }
}
var someInt = 3
someInt.squared() // 9

/*
 
Благодаря расширениям появляется возможность добавлять новые инициализаторы к существующему объектному типу. Так, вы можете расширить типы, например, для обработки экземпляров ваших собственных типов в качестве входных аргументов.
 ПРИМЕЧАНИЕ:
 Для классов расширения могут добавлять только новые вспомогательные инициализаторы. Попытка добавить назначенный инициализатор или деинициализатор приведет к ошибке.

 */

struct Line {
    var pointOne: (Double, Double)
    var pointTwo: (Double, Double)
}
extension Double {
    init(line: Line) {
        self = sqrt(
            pow((line.pointTwo.0 - line.pointOne.0), 2) +
            pow((line.pointTwo.1 - line.pointOne.1), 2)
        )
    } }
var myLine = Line(pointOne: (10,10), pointTwo: (14,10))
var lineLength = Double(line: myLine) // 4

/*
 
 Импортированная в первой строке листинга библиотека Foundation обеспечивает доступ к математическим функциям sqrt(_:) и pow(_:_:)
 (вычисление квадратного корня и возведение в степень), которые требуются для вычисления длины линии на плоскости.
 Структура Line описывает сущность «линия», в свойствах которой указываются координаты точек ее начала и конца.
 Созданный в расширении инициализатор принимает на входе экземпляр класса Line и на основе значений его свойств вычисляет требуемое значение.
    При разработке нового инициализатора в расширении будьте крайне внимательны, чтобы к завершению инициализации каждое из свойств расширяемого типа имело определенное значение.
 Например, если вы напишете расширение уже для типа Line, но в нем проинициализуете значение только для одного из свойств этого типа, это приведет к ошибке.
 
 С помощью расширений у вас есть возможность подписать существующий тип на определенный протокол. Для этого в расширении после имени типа данных через двоеточие необходимо указать список новых протоколов. Тип данных Int подписывается на протокол TextRepresentable, который требует наличия метода asText().
 
 */

protocol TextRepresentable {
    func asText() -> String
}
extension Int: TextRepresentable {
    func asText() -> String {
        return String(self)
    }
}
5.asText() // "5"
