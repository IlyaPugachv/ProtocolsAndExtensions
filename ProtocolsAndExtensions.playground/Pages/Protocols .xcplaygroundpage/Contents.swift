import Foundation

// MARK: - Protocols

/*
 
 Протокол — это перечень требований, которым должен удовлетворять тип данных, соответствующий ему. В более сложных случаях протокол также может содержать не просто требования наличия свойств и методов, но и их конкретную реализацию (об этом будет подробно рассказано в главах про расширения и протокол-ориентированное программирование).
 
 ПРИМЕЧАНИЕ:
 Если к типу данных применяется протокол, это означает, что:
 • тип данных подписан на протокол, или
 • тип данных реализует требования протокола, или
 • тип данных принимает протокол к реализации, или
 • тип данных соответствует протоколу.
 
 В протоколе может содержаться перечень свойств, методов и сабскриптов, которые должны быть реализованы в объектном типе, принимающем его к реализации. Другими словами, протоколы содержат требования к наличию определенных элементов внутри типа данных.
 
 */

protocol ИмяПротокола {
    // тело протокола
}

/*
 
 Для объявления нового протокола используется ключевое слово protocol, после которого указывается его имя (в верхнем верблюжьем регистре).
 Любой объектный тип данных может быть подписан на протокол, неважно, используете вы перечисления (enum), структуры (struct) или класс (class).
 Для того чтобы принять протокол к исполнению, необходимо написать его имя через двоеточие сразу после имени объектного типа данных:
 
 */

struct ИмяПринимающегоТипа: ИмяПротокола {
    // тело структуры
}

/*
 
 После подписки на протокол тип данных обязан выполнить все его требования, то есть реализовать свойства, методы и сабскрипты, описанные в протоколе. При этом тип может быть подписан на произвольное количество протоколов.
 
 */

//enum ИмяПринимающегоТипа: ИмяПротокола, ИмяДругогоПротокола {
// тело перечисления
//}

/*
 
 Если класс не просто принимает протоколы, но и наследует другой класс, то имя родительского класса необходимо указать первым, а за ним через запятую — список протоколов:
 
 */

//   class ИмяПринимающегоКласса: ИмяСуперКласса, ИмяПротокола, ИмяДругогоПротокола {
// тело класса
//   }

/*
 
 В протоколе может содержаться требование реализации одного или нескольких свойств (в том числе свойств типа, указываемых с помощью ключевого слова static).
 При этом для каждого свойства в протоколе указывается:
    • название;
    • тип данных;
    • требования доступности и изменяемости.
 
 */

protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}

/*
 
 Протокол SomeProtocol имеет требования реализации двух свойств. Таким образом, если тип данных подпишется на протокол SomeProtocol, то в нем потребуется реализовать данные свойства, при этом:
    • Первое свойство должно иметь название mustBeSettable,
    • а второе — doesNotNeedToBeSettable.
 Тип данных обоих свойств — Int.
 Свойство doesNotNeedToBeSettable, в свою очередь, должно иметь как минимум геттер.
    Требования доступности и изменяемости определяются с помощью конструкций { get } и { get set }.
 В первом случае у свойства должен быть как минимум геттер, а во втором — и геттер и сеттер.
 В случае, если свойству определено требование { get set }, то оно не может быть вычисляемым «только для чтения» или константой.
    Протокол определяет минимальные требования к типу, то есть тип данных обязан реализовать все, что описано в протоколе, но он может не ограничиваться этим набором.
 Так, для свойства doesNotNeedToBeSettable из предыдущего листинга может быть реализован не только геттер, но и сеттер (в протоколе содержится требование реализации геттера).
 
 */

struct SomeStruct: SomeProtocol {
    var mustBeSettable: Int
    let doesNotNeedToBeSettable: Int
    // дополнительный метод, не описанный в протоколе
    func getSum() -> Int {
        return self.mustBeSettable + self.doesNotNeedToBeSettable
    }
}

/*
 
 Тип данных SomeStruct полностью соответствует описанному ранее протоколу SomeProtocol, но при этом содержит дополнительный метод getSum(), который возвращает сумму свойств. Для указания в протоколе требования к реализации свойства типа необходимо использовать модификатор static.
 
 */

protocol AnotherProtocol {
    static var someTypeProperty: Int { get }
}

/*
 
 Если тип данных подписывается на протокол AnotherProtocol, то в нем обязательно должно быть реализовано свойство типа someTypeProperty.
 
 */

struct AnotherStruct: SomeProtocol, AnotherProtocol {
    var mustBeSettable: Int
    let doesNotNeedToBeSettable: Int
    static var someTypeProperty: Int = 3
    
}

/*
 
 Помимо свойств, протокол может содержать требования к реализации одного или нескольких методов. Для требования реализации метода типа необходимо использовать модификатор static, а для изменяющего метода — mutating.
 ПРИМЕЧАНИЕ:
 Если вы указали ключевое слово mutating перед требованием метода, то указывать его при реализации метода в классе уже не нужно. Данное ключевое слово требуется только при реализации структуры.
 
 */

protocol RandomNumberGenerator {
    var randomCollection: [Int] { get set }
    func getRandomNumber() -> Int?
    mutating func setNewRandomCollection(newValue: [Int])
}

/*
 
 Протокол RandomNumberGenerator содержит требования реализации свойства randomCollection и двух методов: getRandomNumber() и setNewRandomCollection (newValue:).
 При реализации методов в объектном типе необходимо в точности соблюдать все требования протокола: имя метода, наличие или отсутствие входных аргументов, тип возвращаемого значения и модификаторы.
 
 */

struct RandomGenerator: RandomNumberGenerator {
    var randomCollection: [Int] = [1,2,3,4,5]
    func getRandomNumber() -> Int? {
        return randomCollection.randomElement()
    }
    
    mutating func setNewRandomCollection(newValue: [Int]) {
        self.randomCollection = newValue
    }
}

class RandomGeneratorClass: RandomNumberGenerator {
    var randomCollection: [Int] = [1,2,3,4,5]
    func getRandomNumber() -> Int? {
        if let randomElement = randomCollection.randomElement() {
            return randomElement
        }
        return 0 }
    // не используется модификатор mutating
    func setNewRandomCollection(newValue: [Int]) {
        self.randomCollection = newValue
    }
}

/*
 
    Оба объектных типа идентичны в плане функциональности, но имеют некоторые описанные выше различия в реализации требований протокола.
 Протокол может предъявлять требования к реализации инициализаторов. При этом в классах можно реализовать назначенные (designated) или вспомогательные (convenience) инициализаторы. В любом случае перед объявлением инициализатора в классе необходимо указывать модификатор required. Это гарантирует, что вы реализуете указанный инициализатор во всех подклассах данного класса.
 ПРИМЕЧАНИЕ:
 Нет нужды обозначать реализацию инициализаторов протокола модификатором required в классах, которые имеют модификатор final.
 
 */

// protocol Named {
//     init(name: String)
// }
//
// class Person: Named {
//     var name: String
//     required init(name: String) {
//         self.name = name
//     }
// }

/*
 
 Протокол может выступать в качестве типа данных, то есть в определенных случаях вы можете писать не имя конкретного типа, а имя протокола, которому должно соответствовать значение. Протокол, указывающий на множество типов.
 Протокол может выступать в качестве указателя на множество типов данных. С его помощью определяется требование к значению: оно должно иметь ти данных, соответствующий указанному протоколу.
 
 */

func getHash<T: Hashable>(of value: T) -> Int {
    return value.hashValue
}

/*
 
 ПРИМЕЧАНИЕ:
 Функция getHash может принять любое значение типа T, где тип T должен соответствовать протоколу Hashable. Таким образом, данный протокол указывает на целое множество типов данных. Так, вы можете передать в нее значение любого хешируемого типа и получить значение свойства hashValue.
 Операторы as? и as! уже знакомы вам — мы рассматривали их, когда изучали классы. Напомню, что эти операторы производят попытку приведения указанного до оператора значения к указанному после оператора типу данных.
 
 */

protocol HasValue {
    var value: Int { get set }
}
class ClassWithValue: HasValue {
    var value: Int
    init(value: Int) {
        self.value = value
    }
}
struct StructWithValue: HasValue {
    var value: Int
}
// коллекция элементов
let objects: [Any] = [
    2,
    StructWithValue(value: 3),
    true,
    ClassWithValue(value: 6),
    "Usov"
]

/*
 
 Типы данных StructWithValue и ClassWithValue подписаны на протокол HasValue. Значения этих типов вперемешку со значениями других типов помещены в коллекцию objects.
 
 */

for object in objects {
    if let elementWithValue = object as? HasValue {
        print("Значение \(elementWithValue.value)")
    }
}

/*
 
 Консоль
 
 Значение 3
 Значение 6
 
 Оператор as? пытается преобразовать значение к типу данных HasValue (протокол выступает в качестве типа). В случае успеха он выводит значение соответствующего свойства на консоль, а в случае неудачи возвращает nil.
 Вы можете использовать протоколы совместно с оператором is для проверки соответствия типа данных значения этому протоколу.
 
 */

for object in objects {
    print(object is HasValue)
}

/*
 
 Консоль
 
 false
 true
 false
 true
 false
 
    Если проверяемый элемент соответствует протоколу, то при проверке соответствия возвращается значение true, и false — в ином случае.
 Протокол может наследовать один или более других протоколов.
    При этом в него могут быть добавлены новые требования поверх наследуемых — тогда тип, принявший протокол к реализации, будет вынужден выполнить требования всех протоколов в иерархии.
 При наследовании протоколов используется тот же синтаксис, что и при наследовании классов.
 
 */


protocol GeometricFigureWithXAxis {
    var x: Int { get set }
}
protocol GeometricFigureWithYAxis {
    var y: Int { get set }
}
protocol GeometricFigureTwoAxis: GeometricFigureWithXAxis,
                                 GeometricFigureWithYAxis {
    var distanceFromCenter: Float { get }
}
struct Figure2D: GeometricFigureTwoAxis {
    var x: Int = 0
    var y: Int = 0
    var distanceFromCenter: Float {
        let xPow = pow(Double(self.x), 2)
        let yPow = pow(Double(self.y), 2)
        let length = sqrt(xPow + yPow)
        return Float(length)
    } }

/*
 
    Протоколы GeometricFigureWithXAxis и GeometricFigureWithYAxis определяют требование на наличие свойства, указывающего на координату объекта на определенной оси.
 В свою очередь, протокол GeometricFigureTwoAxis объединяет требования двух вышеназванных протоколов, а также вводит дополнительное свойство.
 В результате структура Figure2D, принимающая к реализации протокол GeometricFigureTwoAxis, должна иметь все свойства, описанные во всех трех протоколах.
 Вы можете ограничить применение протокола исключительно на классы, запретив его использование для структур и перечислений. Для этого после имени протокола через двоеточие необходимо указать ключевое слово class, после которого могут быть определены родительские протоколы.
 
 */

// protocol SuperProtocol { }
// protocol SubProtocol: class, SuperProtocol { }
// class  ClassWithProtocol: SubProtocol { } // корректно
// struct StructWithProtocol: SubProtocol { } // ошибка

/*
 
 ПРИМЕЧАНИЕ:
 Протоколы в листинге выше не имеют каких-либо элементов. Это сделано умышленно с целью акцентировать внимание именно на способе объявления протокола и создания на его основе объектного типа.
 В случаях, когда протокол выступает в качестве указателя на множество типов данных, бывает удобнее требовать, чтобы тип данных используемого значения соответствовал не одному, а нескольким протоколам. В этом случае можно пойти двумя путями:
 1. Создать протокол, который подписывается на два родительских протокола, и использовать его в качестве указателя на тип данных.
 2. Использовать композицию протоколов, то есть комбинацию нескольких протоколов.
 
 СИНТАКСИС
 Протокол1 & Протокол2 ...
 Для композиции необходимо указать имена входящих в нее протоколов, разделив их оператором & (амперсанд).
 
 */

protocol Named {
    var name: String { get }
}
protocol Aged {
    var age: Int { get }
}
struct Person: Named, Aged {
    var name: String
    var age: Int }
func wishHappyBirthday(celebrator: Named & Aged) {
    print("С Днем рождения, \(celebrator.name)! Тебе уже \(celebrator.age)!")
}
let birthdayPerson = Person(name: "Джон Уик", age: 46)
wishHappyBirthday(celebrator: birthdayPerson)

/*
 
 Консоль
 С Днем рождения, Джон Уик! Тебе уже 46!
 В данном примере объявляются два протокола: Named и Aged. Созданная структура
 принимает оба протокола и в полной мере выполняет их требования.
 Входным аргументом функции wishHappyBirthday(celebrator:) должно быть значение, которое удовлетворяет обоим протоколам. Таким значением является экземпляр структуры Person, который мы и передаем.
 
 */
